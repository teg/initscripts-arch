#!/bin/bash
#
# /etc/rc.sysinit
#

. /etc/rc.conf
. /etc/rc.d/functions

echo " "
printhl "Arch Linux\n"
printhl "${C_H2}http://www.archlinux.org"
printsep

run_hook sysinit_start

# export standard PATH (will be overridden later when /etc/profile is sourced, but is usefull for UDev)
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"


# mount /proc, /sys, /dev, /dev/pts, /dev/shm and /run (the api filesystems)
/bin/mountpoint -q /proc    || /bin/mount -n -t proc proc /proc -o nosuid,noexec,nodev
/bin/mountpoint -q /sys     || /bin/mount -n -t sysfs sysfs /sys -o nosuid,noexec,nodev
/bin/mountpoint -q /dev			|| /bin/mount -n -t devtmpfs udev /dev -o mode=0755,nosuid
/bin/mkdir -p /dev/{pts,shm}
/bin/mountpoint -q /dev/pts || /bin/mount -n -t devpts devpts /dev/pts -o mode=620,gid=5,nosuid,noexec
/bin/mountpoint -q /dev/shm || /bin/mount -n -t tmpfs tmpfs /dev/tmpfs -o mode=1777,nosuid,nodev
/bin/mountpoint -q /run     || /bin/mount -n -t tmpfs tmpfs /run -o mode=755,size=10M,nosuid,noexec,nodev

# start up our mini logger until syslog takes over
/sbin/minilogd
/sbin/bootlogd -p /run/bootlogd.pid

# Set console verbosity
for cmdarg in $(< /proc/cmdline); do
        [[ "$cmdarg" == verbose ]] && VERBOSE=8 && break
        [[ "$cmdarg" =~ verbose=[1-8] ]] && VERBOSE=${BASH_REMATCH[0]-8} && break
done
/bin/dmesg -n ${VERBOSE:-3}

# enable rtc access
/sbin/modprobe -q -a rtc-cmos rtc genrtc
# If devtmpfs is used, the required RTC device already exists now
# Otherwise, create whatever device is available
if ! [[ -c /dev/rtc || -c /dev/rtc0 ]]; then
	for dev in /sys/class/rtc/rtc0/dev /sys/class/misc/rtc/dev; do
		[[ -e $dev ]] || continue
		IFS=: read -r major minor < "$dev"
		/bin/mknod /dev/rtc c $major $minor
	done

	/sbin/hwclock --systz
fi

stat_busy "Starting UDev Daemon"
echo "" > /sys/kernel/uevent_helper
/sbin/udevd --daemon
stat_done

run_hook sysinit_udevlaunched

# Trigger udev uevents
if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
	stat_busy "Triggering UDev uevents"
	/sbin/udevadm trigger --action=add --type=devices
	/sbin/udevadm trigger --action=add --type=subsystems
	stat_done
fi

# Reads modules from /etc/modules-load.d/?*.conf and loads them,
# the MODULES array in /etc/rc.conf is saved here on shutdown.
/lib/systemd/systemd-modules-load

# Wait for udev uevents
if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
	status "Waiting for UDev uevents to be processed" \
		/sbin/udevadm settle --quiet --timeout=${UDEV_TIMEOUT:-30}
fi

run_hook sysinit_udevsettled

# bring up the loopback interface
[[ -d /sys/class/net/lo ]] && \
	status "Bringing up loopback interface" /sbin/ifconfig lo 127.0.0.1 up

status "Mounting Root Read-only" /bin/mount -n -o remount,ro /

NETFS="nonfs,nonfs4,nosmbfs,nocifs,nocodafs,noncpfs,nosysfs,noshfs,nofuse,nofuseblk,noglusterfs,nodavfs"

if [[ -x /sbin/fsck ]]; then
	stat_busy "Checking Filesystems"
	fsck_reboot() {
		echo "Automatic reboot in progress..."
		/bin/umount -a
		/bin/mount -n -o remount,ro /
		/sbin/reboot -f
		exit 0
	}
	FSCK_OUT=/dev/stdout
	FSCK_ERR=/dev/stdout
	FSCK_FD=
	FORCEFSCK=
	[[ -f /forcefsck ]] && FORCEFSCK="-- -f"
	for cmdarg in $(< /proc/cmdline); do
		[[ "$cmdarg" == forcefsck ]] && FORCEFSCK="-- -f" && break
	done
	run_hook sysinit_prefsck
	/sbin/fsck -A -T -C$FSCK_FD -a -t "$NETFS,noopts=_netdev" $FORCEFSCK >$FSCK_OUT 2>$FSCK_ERR
	fsckret=$?
	if ((fsckret > 1)); then
		stat_fail
	fi
	run_hook sysinit_postfsck
	if (( ( fsckret & 2) == 2)); then
		echo
		echo "********************** REBOOT REQUIRED *********************"
		echo "*                                                          *"
		echo "* The system will be rebooted automatically in 15 seconds. *"
		echo "*                                                          *"
		echo "************************************************************"
		echo
		/bin/sleep 15
		status "Automatic reboot in progress..." /lib/systemd/systemd-shutdown reboot
	elif ((fsckret > 1 && fsckret != 32)); then
		echo
		echo "*****************  FILESYSTEM CHECK FAILED  ****************"
		echo "*                                                          *"
		echo "*  Please repair manually and reboot. Note that the root   *"
		echo "*  file system is currently mounted read-only. To remount  *"
		echo "*  it read-write type: mount -n -o remount,rw /            *"
		echo "*  When you exit the maintenance shell the system will     *"
		echo "*  reboot automatically.                                   *"
		echo "*                                                          *"
		echo "************************************************************"
		echo
		/sbin/sulogin -p
		status "Automatic reboot in progress..." /lib/systemd/systemd-shutdown reboot
	fi
	stat_done
fi

stat_busy "Mounting Local Filesystems"
/bin/mount -n -o remount,rw /

# don't touch /etc/mtab if it is a symlink to /proc/self/mounts
if [[ -L /etc/mtab ]]; then
	:
elif [[ -x /bin/findmnt && -e /proc/self/mountinfo ]]; then
	/bin/findmnt -rnu -o SOURCE,TARGET,FSTYPE,OPTIONS >| /etc/mtab
else
	cat /proc/mounts >| /etc/mtab
fi

run_hook sysinit_premount
# now mount all the local filesystems
/bin/mount -a -t $NETFS -O no_netdev
stat_done

status "Activating Swap" /sbin/swapon -a

stat_busy "Initializing Random Seed"
/lib/systemd/systemd-random-seed load
stat_done

stat_busy "Creating/Removing Missing/Leftover Files"
/lib/systemd/systemd-tmpfiles --create --remove
stat_done

if [[ $HOSTNAME ]]; then
	status "Setting Hostname: $HOSTNAME" /bin/hostname "$HOSTNAME"
fi

# Set the NIS domain name, if necessary
[[ -f /etc/conf.d/nisdomainname ]] && . /etc/conf.d/nisdomainname
if [[ $NISDOMAINNAME ]]; then
	status "Setting NIS Domain Name: $NISDOMAINNAME" /bin/nisdomainname "$NISDOMAINNAME"
fi

stat_busy "Setting Locale: ${LOCALE:=en_US}"
# Flush old locale settings
: >| /etc/profile.d/locale.sh
/bin/chmod 755 /etc/profile.d/locale.sh
# Set user defined locale
echo "export LANG=$LOCALE" >>/etc/profile.d/locale.sh
stat_done

if [[ ${LOCALE,,} =~ utf ]]; then
	stat_busy "Setting Consoles to UTF-8 mode"
	# UTF-8 consoles are default since 2.6.24 kernel
	# this code is needed not only for older kernels,
	# but also when user has set vt.default_utf8=0 but LOCALE is *.UTF-8.
	for i in /dev/tty[0-9]*; do
		/usr/bin/kbd_mode -u < ${i}
		printf "\033%%G" > ${i}
	done
	echo 1 > /sys/module/vt/parameters/default_utf8
	stat_done
	[[ $KEYMAP ]] && status "Loading Keyboard Map: $KEYMAP" /bin/loadkeys -q -u $KEYMAP
else
	stat_busy "Setting Consoles to legacy mode"
	# make non-UTF-8 consoles work on 2.6.24 and newer kernels
	for i in /dev/tty[0-9]*; do
		/usr/bin/kbd_mode -a < ${i}
		printf "\033%%@" > ${i}
	done
	echo 0 > /sys/module/vt/parameters/default_utf8
	stat_done
	[[ $KEYMAP ]] && status "Loading Keyboard Map: $KEYMAP" /bin/loadkeys -q $KEYMAP
fi

# Set console font if required
set_consolefont

/bin/dmesg >| /var/log/dmesg.log

run_hook sysinit_end

# End of file
# vim: set ts=2 sw=2 noet:
